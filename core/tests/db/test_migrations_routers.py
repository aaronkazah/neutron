# core/tests/db/test_migrations_routers.py
from unittest import IsolatedAsyncioTestCase
import datetime

from core.db.base import DATABASES, use_single_database, use_per_app_database
from core.db.model import Model
from core.db.fields import CharField, DateTimeField, IntegerField
from core.db.migrations import MigrationManager, Migration, CreateModel
from core.db.editor import get_schema_editor
from core.db.router import PerAppRouter, SingleDatabaseRouter


class TestPerAppModel(Model):
    name = CharField(max_length=100)

    @classmethod
    def get_app_label(cls) -> str:
        return "migration_test_app"

    # Use default get_table_name which generates migration_test_app_test_per_app_model


class TestSingleModel(Model):
    name = CharField(max_length=100)
    created_at = DateTimeField(default=datetime.datetime.now)

    @classmethod
    def get_app_label(cls) -> str:
        return "migration_test_app"

    # Use default get_table_name which generates migration_test_app_test_single_model


class AnotherAppModel(Model):
    value = IntegerField()

    @classmethod
    def get_app_label(cls) -> str:
        return "another_app"

    # Use default get_table_name which generates another_app_another_app_model


class MigrationRouterTestCase(IsolatedAsyncioTestCase):

    async def asyncSetUp(self):
        # Clean start for each test
        DATABASES.CONFIG = {}
        DATABASES.CONNECTIONS = {}
        # Configure test databases in memory
        DATABASES.configure_app("migration_test_app", memory=True)
        DATABASES.configure_app("another_app", memory=True)
        DATABASES.configure_app("default", memory=True)

        # Create a migration manager
        self.migration_manager = MigrationManager()

    async def asyncTearDown(self):
        await DATABASES.shutdown()

    async def test_migrations_per_app_router(self):
        """Test migrations work correctly with PerAppRouter."""
        router = use_per_app_database()
        self.assertIsInstance(router, PerAppRouter)
        self.assertIsInstance(DATABASES.router, PerAppRouter)

        # Create and apply migration
        migration = Migration(
            "migration_test_app",
            operations=[
                CreateModel(
                    # Use the format expected by CreateModel (app_label.ClassName)
                    "migration_test_app.TestPerAppModel",
                    fields={
                        "id": CharField(primary_key=True),
                        "name": CharField(max_length=100),
                    },
                )
            ],
        )

        # Get connection using the router (should be app-specific)
        connection = await DATABASES.get_connection("migration_test_app")
        self.assertEqual(connection.name, "migration_test_app")

        # Apply migration with the schema editor
        async with get_schema_editor(connection) as schema_editor:
            await migration.apply(
                project_state={},
                schema_editor=schema_editor,
                connection=connection.connection, # Pass the raw aiosqlite connection
            )
            # No explicit commit needed here for aiosqlite when using async with

        # Verify table was created in the app-specific database
        cursor = await connection.connection.execute(
            "SELECT name FROM sqlite_master WHERE type='table' AND name=?",
            # Use the correct snake_case table name generated by the default logic
            ["migration_test_app_test_per_app_model"]
        )
        table = await cursor.fetchone()
        await cursor.close() # Close cursor after use
        self.assertIsNotNone(table)

    async def test_migrations_single_database_router(self):
        """Test migrations work correctly with SingleDatabaseRouter."""
        # Reset database configuration to start fresh
        DATABASES.CONFIG = {}
        DATABASES.CONNECTIONS = {}

        # First, configure the default database
        DATABASES.configure_app("default", memory=True)

        # Set the SingleDatabaseRouter with "default" alias
        router = use_single_database("default")
        self.assertIsInstance(router, SingleDatabaseRouter)
        self.assertEqual(router.default_alias, "default")

        # Create migration
        migration = Migration(
            "migration_test_app",
            operations=[
                CreateModel(
                    # Use the format expected by CreateModel (app_label.ClassName)
                    "migration_test_app.TestSingleModel",
                    fields={
                        "id": CharField(primary_key=True),
                        "name": CharField(max_length=100),
                        "created_at": DateTimeField(default=datetime.datetime.now),
                    },
                )
            ],
        )

        # Get connection - should be routed to the default DB
        connection = await DATABASES.get_connection("migration_test_app")

        # Verify routing to default
        self.assertEqual(connection.name, "default", "Connection should be routed to default database")

        # Apply migration with schema editor
        async with get_schema_editor(connection) as schema_editor:
            await migration.apply(
                project_state={},
                schema_editor=schema_editor,
                connection=connection.connection, # Pass raw connection
            )

        # Define a second model from a different app
        migration2 = Migration(
            "another_app",
            operations=[
                CreateModel(
                    # Use the format expected by CreateModel (app_label.ClassName)
                    "another_app.AnotherAppModel",
                    fields={
                        "id": CharField(primary_key=True),
                        "value": IntegerField(),
                    },
                )
            ],
        )

        # Get connection for second app - should be the same connection
        connection2 = await DATABASES.get_connection("another_app")
        self.assertEqual(connection2.name, "default")
        self.assertEqual(connection, connection2)  # Should be the same connection

        # Apply second migration to the same database
        async with get_schema_editor(connection2) as schema_editor:
            await migration2.apply(
                project_state={},
                schema_editor=schema_editor,
                connection=connection2.connection, # Pass raw connection
            )

        # Verify both tables exist in the single database
        tables = []
        async with connection.connection.execute(
                "SELECT name FROM sqlite_master WHERE type='table'"
        ) as cursor:
            async for row in cursor:
                tables.append(row[0])

        # Use the correct snake_case table names generated by the default logic
        self.assertIn("migration_test_app_test_single_model", tables)
        self.assertIn("another_app_another_app_model", tables)